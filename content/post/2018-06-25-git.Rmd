---
title: git
author: Joe Powers
date: '2018-06-25'
slug: git
categories: []
tags: []
description: ''
featured: ''
featuredalt: ''
featuredpath: ''
linktitle: ''
---

# Overview: 
There are legions of git guides already on the internet. I am writing this one for my team and myself who are newly collaborating on git. I assume that other newcomers to git collaboration will find it useful. This guide will cover the basics of collaborating and undoing mistakes. 

# Undoing in Git
## git revert
The safest way to restore a previous version of your project is to use `git revert 0d1d7fc32`, where "0d1d7fc32" represent the hash number of the commit you want restored. If you just want to restore the most recent commit you can use `git revert HEAD`, which is essentially "UNDO".` IN both cases, git revert "undoes" work by restoring an older commit as the newest commit, while leaving in place any commits that occured between the restored commit and the current commit. In contrast, `git reset` would have taken turnedback the clock to the older commit and erased all the "in between commits" in the process. 

There are other commands for restoring your project--or files within it--to specific prior states, but `git revert` is a good place to start. 

__ How does git revert behave within a branch? 

Atlassian offers an excellent tutorial of [git revert](https://www.atlassian.com/git/tutorials/undoing-changes/git-revert).

git revert will revert your project without erasing the commits in between your prior commit and the current reversion. 

Git revert brings an older commit forward to become the head, but it leaves the commit "in between" in place. 

In contrast git reset will move the HEAD back to a prior commit and erase the commits in between. 

Great conceptual model of [restore git commands](https://www.atlassian.com/git/tutorials/resetting-checking-out-and-reverting for more conceptual clarity).

##[git-tower](https://www.git-tower.com/learn/git/faq/restore-repo-to-previous-revision)

Extract specific files as they were in a previous commit: 
`git checkout 0d1d7fc32 -- file_name.ext`

Create a new branch that reflects progress at prior commit:

`git checkout -b add_feature_x_old 0d1d7fc32`

## [Undoing things in git](https://www.git-tower.com/learn/git/ebook/en/command-line/advanced-topics/undoing-things)

 Update just your last commit message
 `$ git commit --amend -m "This is the correct message"`

If you forgot to add some stuff in your last commit: 
`$ git add some/changed/file.ext`
`$ git commit --amend -m "commit message"`

Restore a local file to its state at a prior commit
`$ git checkout HEAD file/to/restore.ext`

Restore a local repo to its state at a prior commit and delete all commits in between:

`git reset --hard 0d1d7fc32`


[HEAD = most recent commit of the checked out branch](https://www.youtube.com/watch?reload=9&v=ZaI1co-rt9I)

git checkout and git reset, move the HEAD and branch ref pointers to a specified commit.


# Core vocab: 

`HEAD` refers to the project status at the most recent commit in the checked-out branch. Also the commit that the current working tree stemmed from. 
    * If you checkout a branch, HEAD symbolically refers to that branch, indicating that the branch name should be updated after the next commit operation.
    * If you checkout a specific commit, HEAD refers to that commit only. This is referred to as a `detached HEAD`, and occurs, for example, if you check out a tag name.

The `index` (also known as the `cache` or `staging area`) is where files are staged via `git add` before they are committed to the local git repo. 

You use `git status` to see what files are staged in your index and awaiting commit. 

A `commit` is a snapshot of your working tree at a point in time

The files you are directly working upon live in your `working directory`, `project`, `working tree`. These all can mean the same thing. 

Great dictionary of [git terminology at git from the bottom up](https://jwiegley.github.io/git-from-the-bottom-up/)

What is the `state` 














